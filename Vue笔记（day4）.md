### 15.1.v-text指令

> v-text会直接覆盖掉当前元素中所有的内容
> 
> 如果要更新部分内容，请使用插值语法
> 
> v-text不会解析任何标签，类似于js中textContent语法

### 15.2.v-html指令

> v-html会直接覆盖掉当前元素中所有的内容
> 
> 如果要更新部分内容，请使用插值语法
> 
> v-html可以解析html提供的标签，类似于js中innerHtml语法
> 
> 插值语法不能解析标签

### 16.2.数据劫持

在vm中可以看到每一层都有数据劫持

```
 data: {
                a: {
                    b: {
                        c: {
                            d: 2
                        }
                    }
                }
            }
```

### 16.3.数组的数据劫持

为了能够响应数组内部的变化，vue作出了一些操作

> 变更方法：Vue将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
> 
> - push（）
> 
> - pop（）
> 
> - shift（）
> 
> - unshift（）
> 
> - splice（）
> 
> - sort（）
> 
> - reverse（）
> 
> - 都是修改原数组的方法
> 
> 非变更方法：例如
> 
> - filter（）
> 
> - concat（）
> 
> - slice（）
> 
> 它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组
> 
> Vue做了一些操作，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作

> 对于数组来说，vue并没有给每一个数组中的元素做数据劫持处理，所以以这样的方式修改数组，视图不会更新
> 
> this.arr[0] = 1
> 
> 这样情况就可以劫持（响应）到数据的更新
> 
> this.arr=[1,"b","c"]
> 
> 以下这种方法可行
> 
> this.arr.push("e")
> 
> 我们使用的数组方法，并不是Array的原型对象上的方法，而是vue自己封装的方法

### 17.2.vue初始化流程

- beforeCreate

在实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用

生命周期函数的this都是指向vm实例

- created

> 在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：
> 
> 数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且$el property目前尚不可用

### 17.3.挂载流程

渲染的模板 优先考虑渲染template配置的模板

### 18.2.Vue.extend

> Vue.extend是创建组件的一个方法
> 
> Vue.extend得到的vc对象是一个小型的vm（比如没有el属性，因为一个Vue只挂载一次，每一个组件都绑定在vm上即可）
> 
> Vue组件定义时的配置的data需要写成一个函数，避免组件后期复用时产生数据的干扰