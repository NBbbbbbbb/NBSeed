### 7.3.事件对象

事件函数在绑定的时候可以加或者不加小括号（函数都是在事件发生以后才调用的）

> 当不需要传参的时候，可以不添加小括号（直接在函数中书写event形参，就代表事件对象）
> 
> 当需要传参的时候，添加小括号（添加小括号之后，直接在函数中书写形参event就失效了）

### 7.4.事件函数传参

当事件函数需要传参的时候，需要添加小括号，添加小括号之后，就会把event事件对象的参数位置给占用了

> 我们可以手动传递$event作为事件对象
> 
> $event的书写位置随意，只要实参和形参顺序对应即可

### 7.5.阻止默认事件

vue中的事件对象做了封装，和普通DOM中的事件对象用法一致

```javascript
 methods: {
                linkClick(e) {
                    //vue中的事件对象做了封装 和普通DOM中的事件对象用法一致
                    e.preventDefault();
                }
            }
```

### 7.6.事件修饰符

在绑定事件的时候可以在@事件类型后添加.修饰符，可以执行修饰符的功能

> .prevent 当前事件就是阻止默认事件
> 
> .stop 当前事件阻止传播
> 
> .prevent.stop 阻止传播和默认事件
> 
> .lasy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步
> 
> number 如果想自动将用户的输入值转为数值类型，可以给v-model添加number修饰符
> 
> trim 如果要自动过滤用户输入的首尾空白字符，可以给v-model添加trim修饰符

键修饰符，键别名

> .enter 回车键
> 
> .space
> 
> .delete
> 
> .tab tab键只能绑定给keydown事件
> 
> .esc
> 
> .up
> 
> .down
> 
> .left
> 
> .right

键修饰符，键码

> .13 回车
> 
> .xxx（键码）

### 8.1.style的动态绑定-写法一

> style进行动态绑定的时候，style=后必须书写引号，引号中是js语法区域
> 
> style动态绑定的时候，语法区域其实是一个对象

### 8.2.style的动态绑定-写法二

style进行动态绑定的时候，对象会直接放在data中使用

### 8.3.class的动态绑定-方法一

class动态绑定方式1：str形式

> class的值是一个字符串
> 
> 常用于一个类名，且这个类名不确定

### 8.4.class的动态绑定-方法二

class动态绑定方式2：对象形式

> class的值是一个对象，对象的key就是各个类名，value是布尔值，代表是否开启当前的类
> 
> 用于类名已经确定，但是不确定是否使用

Vue还提供了简略的事件写法，在事件后直接书写事件逻辑即可（常用于比较简单的逻辑），如果需要获取vm上的数据，则不需要添加this，直接获取

例如：

```javascript
<button @click="classObj.color=!classObj.color">点我取消或者添加背景颜色</button>
```

### 8.5.class的动态绑定-方法三

class动态绑定方式3：数组形式

> class的值是一个数组，数组中放入所有当前元素需要的类名，我们可以通过操作这个数组，来删除或者添加类名
> 
> 用于类名不确定，个数不确定

### 9.1.案例1-插值语法实现

在模板中书写太多逻辑，不美观，不直观

例如：

```html
 <div id='app'>
        姓：<input type="text" v-model="firstName">
        <br>
        名：<input type="text" v-model="lastName">
        <br>
        全名：{{(firstName + '-' + lastName).toUpperCase()}}
    </div>
```

### 9.2.案例2-封装函数实现

> 当使用多次的时候，函数会调用多次
> 
> 使用函数调用得到值的方式，并不能直观的展示这个数据

### 9.3.案例3-计算属性实现

> 计算属性是当一个数据受多个数据影响的时候，或者值是通过计算得来的时候才使用
> 
> 计算属性通常以函数的形式写在computed选项中，但是使用的时候是按照属性来使用
> 
> 计算属性监视内部使用的属性的变化，一旦发生变化，计算属性就要重新计算，计算好 得到一个值，并保留供未来使用这个值，
> 
> 如果计算属性监视内部使用的属性没有发生变化，则计算属性就不会重新计算，仍旧使用上一次计算好的值
> 
> 主要做的是一条数据受多条数据的影响

### 9.4.案例4-计算属性实现读写

计算属性中可以给某个属性设置getter和setter函数，实现计算属性的读和写

setter函数的参数就是在设置计算属性时给的值

计算属性书写区域如下：

```javascript
computed: {
                fullName: {
                    get() {
                        return this.firstName + "-" + this.lastName;
                    },
                    set(val) {
                        //setter函数的参数就是 在设置计算属性时给的值
                        console.log(val);
                        [this.firstName, this.lastName] = val.split("-");
                    }
                }
            }
```

### 10.3.监听属性的使用

> 监听isHot的函数，当isHot发生改变的时候，调用当前的函数
> 
> handler接收两个参数，分别是newValue和oldValue代表新值和旧值

```javascript
watch: {
                isHot: {
                    handler(newValue, oldValue) {
                        //函数体
                    }
                }
            }
```

### 10.4.监听计算属性

除了监听一般属性，watch还可以监听计算属性

### 10.5.立即监视

配置立即监视

- immediate：true

立即监听的时候，初始的newValue是当前值，oldValue是undefined

### 10.6深度监听

监听一个对象的时候，只能监听到当前的地址是否发生变化了，无法监听内部属性是否改变，因此要使用深度监听

- deep：true

### 10.7.监听简写

如果就监听属性不需要配置立即监听和深度监听，则可以书写为简写模式

- price（）{}
